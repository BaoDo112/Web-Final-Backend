generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ═══════════════════════════════════════════════════════════════
// ENUMS
// ═══════════════════════════════════════════════════════════════

enum Role {
  INTERVIEWEE   // Người được phỏng vấn (Ứng viên)
  INTERVIEWER   // Người phỏng vấn (Mentor)
  ADMIN         // Quản trị viên
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum BookingStatus {
  PENDING     // Chờ xác nhận
  CONFIRMED   // Đã xác nhận
  COMPLETED   // Đã hoàn thành
  CANCELLED   // Đã hủy
  EXPIRED     // Đã hết hạn
}

enum ContentType {
  ARTICLE       // Bài viết text/markdown
  VIDEO         // Video hướng dẫn (có videoUrl)
  QUESTION_SET  // Bộ câu hỏi (có questions JSON)
  TUTORIAL      // Hướng dẫn step-by-step
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum ContentStatus {
  DRAFT         // Nháp
  PENDING_REVIEW // Chờ duyệt (Admin)
  PUBLISHED     // Đã xuất bản
  ARCHIVED      // Lưu trữ
}

enum TokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
}

enum NotificationType {
  BOOKING_REQUEST
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_REMINDER
  NEW_REVIEW
  NEW_MESSAGE
  PROFILE_APPROVED
  CONTENT_APPROVED
  SYSTEM
}

// ═══════════════════════════════════════════════════════════════
// USER & PROFILE
// ═══════════════════════════════════════════════════════════════

model User {
  id            String       @id @default(uuid())
  email         String       @unique
  password      String?      // Nullable cho Google Login
  name          String?
  avatar        String?
  
  // Profile Fields
  gender        Gender?
  dateOfBirth   DateTime?
  location      String?
  bio           String?      @db.Text
  phone         String?
  
  // Auth & RBAC
  role          Role         @default(INTERVIEWEE)
  provider      AuthProvider @default(LOCAL)
  providerId    String?      // Google ID
  isVerified    Boolean      @default(false)
  isActive      Boolean      @default(true)  // Admin có thể disable
  refreshToken  String?
  
  // Stats (Denormalized)
  totalBookings Int          @default(0)
  currentStreak Int          @default(0)
  lastActiveAt  DateTime?
  
  // Soft Delete
  deletedAt     DateTime?
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  
  // Relations
  interviewerProfile InterviewerProfile?
  contents           Content[]     // Thay vì posts + videos riêng
  sentMessages       Message[]
  bookingsAsUser     Booking[]     @relation("UserBookings")
  bookingsAsMentor   Booking[]     @relation("MentorBookings")
  tokens             Token[]
  reviewsWritten     Review[]      @relation("ReviewAuthor")
  reviewsReceived    Review[]      @relation("ReviewTarget")
  notifications      Notification[]

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@index([deletedAt])
}

model InterviewerProfile {
  id            String     @id @default(uuid())
  
  // Professional Info
  title         String?    // "Senior Software Engineer"
  company       String?    // "Google"
  bio           String?    @db.Text
  skills        String[]   // ["React", "NestJS", "System Design"]
  experience    Int        @default(0) // Số năm kinh nghiệm
  hourlyRate    Int        @default(0)
  cvUrl         String?
  linkedinUrl   String?
  
  // Availability (JSON for flexibility)
  // Format: { "mon": ["09:00-12:00", "14:00-18:00"], "tue": [...] }
  availability  Json?
  timezone      String     @default("Asia/Ho_Chi_Minh")
  
  // Stats (Denormalized)
  rating        Float      @default(0)
  totalReviews  Int        @default(0)
  totalSessions Int        @default(0)
  
  // Admin approval workflow
  isApproved    Boolean    @default(false)
  approvedAt    DateTime?
  approvedBy    String?    // Admin userId who approved
  rejectionNote String?    // Lý do từ chối (nếu có)
  
  userId        String     @unique
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@index([isApproved])
  @@index([rating])
}

// ═══════════════════════════════════════════════════════════════
// AUTH TOKENS
// ═══════════════════════════════════════════════════════════════

model Token {
  id        String    @id @default(uuid())
  token     String    @unique
  type      TokenType
  expiresAt DateTime
  usedAt    DateTime? // Đã sử dụng chưa
  
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime  @default(now())
  
  @@index([token])
  @@index([userId, type])
  @@index([expiresAt])
}

// ═══════════════════════════════════════════════════════════════
// BOOKING & SESSIONS
// ═══════════════════════════════════════════════════════════════

model Booking {
  id          String        @id @default(uuid())
  
  // Time
  startTime   DateTime
  endTime     DateTime
  duration    Int           @default(60) // minutes
  timezone    String        @default("Asia/Ho_Chi_Minh")
  
  // Status
  status      BookingStatus @default(PENDING)
  meetingLink String?
  note        String?       @db.Text
  
  // Cancellation tracking
  cancelledAt DateTime?
  cancelledBy String?       // userId who cancelled
  cancelReason String?
  
  // Soft Delete
  deletedAt   DateTime?
  
  // Relations
  userId      String
  user        User          @relation("UserBookings", fields: [userId], references: [id], onDelete: Restrict)
  
  mentorId    String
  mentor      User          @relation("MentorBookings", fields: [mentorId], references: [id], onDelete: Restrict)
  
  messages    Message[]
  review      Review?
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@unique([mentorId, startTime])
  @@index([userId])
  @@index([mentorId])
  @@index([status])
  @@index([startTime])
  @@index([deletedAt])
}

model Message {
  id        String   @id @default(uuid())
  content   String   @db.Text
  isEdited  Boolean  @default(false)
  
  bookingId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  senderId  String
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Restrict)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([bookingId])
  @@index([senderId])
  @@index([createdAt])
}

// ═══════════════════════════════════════════════════════════════
// CONTENT (Unified: Articles, Videos, Question Sets)
// ═══════════════════════════════════════════════════════════════

model Content {
  id           String        @id @default(uuid())
  
  // Basic Info
  title        String
  slug         String        @unique // URL-friendly, e.g., "top-10-interview-questions"
  description  String?       @db.Text // Short summary
  body         String?       @db.Text // Main content (Markdown)
  
  // Type & Categorization
  type         ContentType   @default(ARTICLE)
  difficulty   Difficulty?
  category     String?       // "Frontend", "Backend", "System Design"
  tags         String[]
  
  // Media
  thumbnailUrl String?
  videoUrl     String?       // For VIDEO type
  fileUrls     String[]      // Attachments
  
  // For QUESTION_SET type
  // Format: [{ question: "...", answer: "...", hint: "..." }]
  questions    Json?
  
  // Metadata
  duration     Int?          // minutes (for video/tutorial)
  readTime     Int?          // minutes (for article)
  
  // Publishing
  status       ContentStatus @default(DRAFT)
  publishedAt  DateTime?
  
  // Stats (Denormalized)
  viewCount    Int           @default(0)
  likeCount    Int           @default(0)
  rating       Float         @default(0)
  reviewCount  Int           @default(0)
  
  // SEO
  metaTitle    String?
  metaDesc     String?
  
  // Soft Delete
  deletedAt    DateTime?
  
  // Relations
  authorId     String
  author       User          @relation(fields: [authorId], references: [id], onDelete: Restrict)
  reviews      Review[]
  
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  
  @@index([type])
  @@index([status])
  @@index([authorId])
  @@index([category])
  @@index([publishedAt])
  @@index([deletedAt])
}

// ═══════════════════════════════════════════════════════════════
// REVIEWS
// ═══════════════════════════════════════════════════════════════

model Review {
  id        String   @id @default(uuid())
  rating    Int      // 1-5 (validated in app layer)
  comment   String?  @db.Text
  
  // Author
  authorId  String
  author    User     @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Restrict)
  
  // Target: ONE of these (polymorphic)
  bookingId    String?  @unique // 1 booking = 1 review (from interviewee)
  booking      Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  contentId    String?
  content      Content? @relation(fields: [contentId], references: [id], onDelete: Cascade)
  
  targetUserId String?  // Review cho Interviewer profile
  targetUser   User?    @relation("ReviewTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  
  // Moderation
  isApproved   Boolean  @default(true) // Admin có thể ẩn review spam
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([authorId, contentId])      // 1 user, 1 review per content
  @@unique([authorId, targetUserId])   // 1 user, 1 review per interviewer
  @@index([authorId])
  @@index([contentId])
  @@index([targetUserId])
  @@index([rating])
  @@index([isApproved])
}

// ═══════════════════════════════════════════════════════════════
// NOTIFICATIONS
// ═══════════════════════════════════════════════════════════════

model Notification {
  id        String           @id @default(uuid())
  type      NotificationType
  title     String
  message   String           @db.Text
  data      Json?            // Extra data
  
  isRead    Boolean          @default(false)
  readAt    DateTime?
  
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime         @default(now())
  
  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead])
}
